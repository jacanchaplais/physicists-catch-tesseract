# Copyright 2025 Pasteur Labs. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Tesseract API module for projectile
# Generated by tesseract 0.9.0 on 2025-07-11T10:47:28.788710

import inspect
import typing
from collections import defaultdict
from itertools import product

from pydantic import BaseModel
from tesseract_core.runtime import Differentiable, Float32

import jax
import jax.numpy as jnp

RECIP_GRAV_STRENGTH = 1.0 / 9.81
OUTPUT_FUNCS = {
    "distance": lambda speed, angle: (
        speed * speed * RECIP_GRAV_STRENGTH * jnp.sin(2.0 * angle)
    ),
    "time": lambda speed, angle: (
        2.0 * speed * RECIP_GRAV_STRENGTH * jnp.sin(angle)
    ),
}


def arg_names(func: typing.Callable[[...], typing.Any]) -> list[str]:
    """Returns the names of the arguments of a function, in order."""
    return inspect.getfullargspec(func).args


GRAD_FUNCS = {
    output_name: {
        input_name: jax.grad(func, argnums=num)
        for num, input_name in enumerate(arg_names(func))
    }
    for output_name, func in OUTPUT_FUNCS.items()
}

#
# Schemas
#

class InputSchema(BaseModel):
    speed: Differentiable[Float32]
    angle: Differentiable[Float32]


class OutputSchema(BaseModel):
    distance: Differentiable[Float32]
    time: Differentiable[Float32]

#
# Required endpoints
#


def apply(inputs: InputSchema) -> OutputSchema:
    return OutputSchema(
        distance=OUTPUT_FUNCS["distance"](speed=inputs.speed, angle=inputs.angle),
        time=OUTPUT_FUNCS["time"](speed=inputs.speed, angle=inputs.angle),
    )

#
# Optional endpoints
#

def jacobian(
    inputs: InputSchema,
    jac_inputs: set[str],
    jac_outputs: set[str]
) -> dict[str, dict[str, float]]:
    grads = defaultdict(dict)  # empty dict instantiated if value missing
    for output_name, input_name in product(jac_outputs, jac_inputs):
        grads[output_name][input_name] = GRAD_FUNCS[output_name][input_name](
            inputs.speed, inputs.angle
        ).item()
    return dict(grads)
